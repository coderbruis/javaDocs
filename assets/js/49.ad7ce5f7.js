(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{443:function(t,e,l){"use strict";l.r(e);var s=l(2),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"概述"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),l("p",[t._v("在windows中，“句柄”是用来表示标识对象的一个唯一整数，windows使用各种各样的句柄表示诸如应用程序实例、窗口、位图等；而在linux中，不叫句柄，而成为文件描述符（FD），在Linux中一切皆文件。")]),t._v(" "),l("h2",{attrs:{id:"_1-select"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-select"}},[t._v("#")]),t._v(" 1. select")]),t._v(" "),l("h2",{attrs:{id:"_2-poll"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-poll"}},[t._v("#")]),t._v(" 2. poll")]),t._v(" "),l("h2",{attrs:{id:"_3-epoll"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-epoll"}},[t._v("#")]),t._v(" 3. epoll")]),t._v(" "),l("p",[t._v("epoll的出现，解决了select和poll的不足。")]),t._v(" "),l("p",[t._v("epoll是在Linux2.5.44中首度出现的，和select和poll不同，epoll提供了三个系统函数，\n分别为：\nepoll_create\nepoll_ctl\nepoll_wait")]),t._v(" "),l("blockquote",[l("p",[t._v("epoll_create是用来创建一个epoll描述符的：")])]),t._v(" "),l("div",{staticClass:"language-c line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-c"}},[l("code",[l("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),l("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token string"}},[t._v("<sys/epoll.h>")])]),t._v("\n"),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_create")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),l("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回值：epoll 描述符ID")]),t._v("\n")])]),t._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[t._v("1")]),l("br"),l("span",{staticClass:"line-number"},[t._v("2")]),l("br")])]),l("blockquote",[l("p",[t._v("epoll_ctl用来增/删/改内核中的事件表：")])]),t._v(" "),l("div",{staticClass:"language-c line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-c"}},[l("code",[l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_ctl")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" op"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("event"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),l("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回值：成功时返回 0 ，失败时返回 -1")]),t._v("\n")])]),t._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[t._v("1")]),l("br")])]),l("p",[t._v("epfd 是 epoll 描述符。\nop 是操作类型（增加/删除/修改）。\nfd 是希望监视的文件描述符。")]),t._v(" "),l("blockquote",[l("p",[t._v("epoll_wait用来等待事件")])]),t._v(" "),l("div",{staticClass:"language-c line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-c"}},[l("code",[l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token function"}},[t._v("epoll_wait")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" epfd"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("epoll_event")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("result_events"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maxevents"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),l("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" timeout"),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),l("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),l("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回值：已就绪的描述符个数。超时时为 0 ，错误时为 -1")]),t._v("\n")])]),t._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[t._v("1")]),l("br")])]),l("ul",[l("li",[t._v("epfd是epoll描述符")]),t._v(" "),l("li",[t._v("result_events是 epoll_event 结构体的指针，它将指向的是所有已经准备好的事件描述符相关联的 epoll_event（在上个步骤里调用 epoll_ctl 时关联起来的）。下面的例子可以让你知道这个参数的意义")]),t._v(" "),l("li",[t._v("maxevents是返回的最大事件个数，也就是你能通过 result_events 指针遍历到的最大的次数")]),t._v(" "),l("li",[t._v("timeout 是等待超时的毫秒数")])]),t._v(" "),l("h3",{attrs:{id:"_3-1-epoll中涉及的数据结构"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-epoll中涉及的数据结构"}},[t._v("#")]),t._v(" 3.1 epoll中涉及的数据结构")]),t._v(" "),l("blockquote",[l("p",[t._v("epollfd对象")])]),t._v(" "),l("p",[t._v("Linux通过epoll_create创建一个epollfd，内核就会分配一个eventpoll与之对应，由于eventpoll非常的底层，此处就不再深入探究了，有兴趣的小伙伴点以下连接去研究。\n"),l("a",{attrs:{href:"https://www.cnblogs.com/zengyiwen/p/7213f3303eca4bb08fd270f7d5772100.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linux之epoll详细解析实现"),l("OutboundLink")],1)]),t._v(" "),l("p",[t._v("创建了epollfd之后，epollfd会存放在fd列表中，除此之外，epoll_create还会在内核cache里建一个红黑树用于存储以后epoll_ctl传来的socket，同时还会再建立一个list链表，用于存已经就绪的socket事件。")]),t._v(" "),l("p",[t._v("Linux会通过epoll_ctl来注册一个文件描述符fd，也就是监听一个socket连接，而注册的fd会被维护在之前在内核中建立的一颗红黑树上。（红黑树的搜索、插入和删除时间复杂度为O(logn)）。epoll_ctl主要还是向红黑树中用于添加、删除、修改事件。")]),t._v(" "),l("p",[t._v("当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的fd到用户态而已。")]),t._v(" "),l("blockquote",[l("p",[t._v("这里有个疑问，准备就绪的list链表是如何维护的呢？")])]),t._v(" "),l("p",[t._v("当epoll_ctl被调用时，除了把socket注册在内核维护的红黑树上之外，还会给内核中断处理程序表注册一个回调函数，为的就是当注册在红黑树上的socket有事件响应时，（通过网卡、DMA、再到socket时，会触发中断程序）能够调用中断回调函数，然后就把就绪的socket维护到了list链表里。这样epoll_wait就发现list链表中有就绪的socket就直接返回了，事件复杂度为O(1)。")]),t._v(" "),l("blockquote",[l("p",[t._v("边沿触发和水平触发")])]),t._v(" "),l("p",[t._v("epoll有两种模型：边沿触发edge-triggered (ET)， 水平触发level-triggered (LT)。  详细内容参考："),l("a",{attrs:{href:"https://www.cnblogs.com/cobbliu/articles/10782804.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Epoll - 水平触发和边缘触发"),l("OutboundLink")],1)]),t._v(" "),l("blockquote",[l("p",[t._v("水平触发")])]),t._v(" "),l("p",[t._v("当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！")]),t._v(" "),l("blockquote",[l("p",[t._v("边沿触发")])]),t._v(" "),l("p",[t._v("当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！")]),t._v(" "),l("p",[t._v("select(),poll()模型都是水平触发模式，信号驱动IO是边缘触发模式，epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发。")]),t._v(" "),l("p",[t._v("epoll高效的本质在于：")]),t._v(" "),l("ul",[l("li",[t._v("减少了用户态和内核态的fd拷贝")]),t._v(" "),l("li",[t._v("减少了对可读可写fd的遍历")]),t._v(" "),l("li",[t._v("mmap 加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝")]),t._v(" "),l("li",[t._v("IO性能不会随着监听的文件描述的数量增长而下降")]),t._v(" "),l("li",[t._v("使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间")])]),t._v(" "),l("h2",{attrs:{id:"_4-select、poll、epoll对比"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-select、poll、epoll对比"}},[t._v("#")]),t._v(" 4. select、poll、epoll对比")]),t._v(" "),l("ol",[l("li",[l("p",[t._v("select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。")])]),t._v(" "),l("li",[l("p",[t._v("select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);