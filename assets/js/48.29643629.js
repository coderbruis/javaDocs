(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{442:function(e,t,n){"use strict";n.r(t);var o=n(2),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"_1-netty-channel和jdk-channel之间的异同？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-netty-channel和jdk-channel之间的异同？"}},[e._v("#")]),e._v(" 1. Netty Channel和JDK Channel之间的异同？")]),e._v(" "),n("p",[e._v("Netty内部包装了JDK channel对象，并将内部的NioServerSocketChannel、NioSocketChannel设置为非阻塞对象；")]),e._v(" "),n("h2",{attrs:{id:"_2-netty中的nioeventloop？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-netty中的nioeventloop？"}},[e._v("#")]),e._v(" 2. Netty中的NioEventLoop？")]),e._v(" "),n("p",[e._v("channel注册到NioEventLoop中，NioEventLoop可以处理普通任务以及IO事件，主要是将Channel注册到NioEvenLoop的selector上，NioEventLoop会绑定一个selector对象用于去监听事件，注册的过程是JDK底层的事情。NioEventLoopGroup和NioEventLoop就类似于线程池和线程的概念，但是NioEventLoop又不是一个普通的线程，它实现了SingleThreadEventExecutor，又类似于线程池。所以Netty将channel注册到NioEventLoop就是将Netty封装过的JDK底层channel注册到NioEventLoop上的selector去。")]),e._v(" "),n("h2",{attrs:{id:"_3-netty中的select流程？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-netty中的select流程？"}},[e._v("#")]),e._v(" 3. Netty中的select流程？")]),e._v(" "),n("p",[e._v("NioEventLoop的工作过程，NioEventLoop对象创建完之后，并且经过run方法的调用之后，会执行一个for(;;)死循环，死循环首先会执行一个IO的选择策略，去决定是调用Selector#selectNow还是Selector#select，selectNow是非阻塞的，select是阻塞的，select监听知道有事件就绪之后，才会从改方法返回。使用哪种策略呢，主要还是看NioEventLoop内部维护的一个任务队列是不是有本地任务需要执行，如果任务队列中包含了本地任务，那如果是select阻塞的话，就不优雅了，因为这延误了非IO的任务执行，所以此时需要调用selectNow非阻塞的方法，接下来就去处理SelectKeys了（此处SelectKeys经过了优化），SelectKeys集合表示是本次轮训筛选出的就绪的Channel事件，然后迭代这个SelectKeys集合，然后拿到key中对应的关联的hannel，然后判断对应事件是读就绪、写就绪。")]),e._v(" "),n("p",[e._v("比如是读就绪，那么就会把这个Socket缓冲区内的数据load到Netty内存分配器分配出的一个ByteBuf对象中，然后调用当前ChannelPipeline里的业务处理器ChannelHandler对象，也是触发fireChannelRead事件，然后往pipeline里传播读事件，就这样可以将读到的数据进行业务处理。")]),e._v(" "),n("p",[e._v("NioEventLoop自旋处理完IO事件之后，就会处理任务队列里存在的任务，处理逻辑比较简单就是直接拿到任务后直接run执行。")]),e._v(" "),n("h2",{attrs:{id:"_4-channelpipeline做了什么优化？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-channelpipeline做了什么优化？"}},[e._v("#")]),e._v(" 4. ChannelPipeline做了什么优化？")]),e._v(" "),n("p",[e._v("ChannelPipeline有一个优化，mask。每个ChannelHandler都有一个executionMask对象，它是一个二进制的int变量，它表示的是当前这个Handler对上传Inbound基类或者outBound基类指定的接口方法有没有进行复写Override，如果有复写，那么再mask二进制中表示这个方法的big是1，否则是0。这样设计后，可以避免一些空调用，也就是说向后传递的时候要找到第一个实现了响应时间的Handler，中间跳过那些没有实现响应事件的Handler，这样做能够省一点栈内存空间，对大流量服务器内存来说，这个优化点非常的牛逼。")]),e._v(" "),n("h2",{attrs:{id:"_5-nioeventloop是线程吗？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-nioeventloop是线程吗？"}},[e._v("#")]),e._v(" 5. NioEventLoop是线程吗？")]),e._v(" "),n("p",[e._v("看NioEventLoop的继承体系可以发现，它继承了SingleThreadEventExecutor。它不像是一个单线程，而更新是一个单线程的线程池，NioEventLoop对象\n内部有队列，所以说NioEventLoop对象即要做selector轮训监听事件，也要执行任务队列的普通任务。")]),e._v(" "),n("h2",{attrs:{id:"_6-nioeventloop内部的任务队列做过优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-nioeventloop内部的任务队列做过优化"}},[e._v("#")]),e._v(" 6. NioEventLoop内部的任务队列做过优化.....")]),e._v(" "),n("Boxx",{attrs:{type:"tip",content:"本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。"}})],1)}),[],!1,null,null,null);t.default=a.exports}}]);