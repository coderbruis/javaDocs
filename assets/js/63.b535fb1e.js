(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{456:function(e,r,t){"use strict";t.r(r);var a=t(2),s=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-rocketmq整体介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-rocketmq整体介绍"}},[e._v("#")]),e._v(" 1. RocketMQ整体介绍")]),e._v(" "),t("p",[e._v("RocketMQ是一款分布式、 队列模型的消息中间件。")]),e._v(" "),t("p",[e._v("最新版本为: 4.3.x版本(支持分布式事务)")]),e._v(" "),t("blockquote",[t("p",[e._v("RocketMQ支持的功能：")])]),e._v(" "),t("ol",[t("li",[e._v("支持集群模型、负载均衡、水平扩展能力")]),e._v(" "),t("li",[e._v("亿级别的消息堆积能力")]),e._v(" "),t("li",[e._v("采用零拷贝的原理、顺序写盘、随机读")]),e._v(" "),t("li",[e._v("丰富的API使用")]),e._v(" "),t("li",[e._v("代码优秀，底层通信框架采用Netty NIO框架")]),e._v(" "),t("li",[e._v("NameServer代替Zookeeper")]),e._v(" "),t("li",[e._v("强调集群无单点，可扩展，任意一点高可用，水平可扩展")]),e._v(" "),t("li",[e._v("消息失败重试机制、消息可查询")]),e._v(" "),t("li",[e._v("开源社区活跃、成熟度高（经过双十一考验）")])]),e._v(" "),t("h2",{attrs:{id:"_2-rocketmq基础概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-rocketmq基础概念"}},[e._v("#")]),e._v(" 2. RocketMQ基础概念")]),e._v(" "),t("h3",{attrs:{id:"_2-1-消息模型（message-model）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-消息模型（message-model）"}},[e._v("#")]),e._v(" 2.1 消息模型（Message Model）")]),e._v(" "),t("p",[e._v("RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。")]),e._v(" "),t("h3",{attrs:{id:"_2-2-消息生产者（producer）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-消息生产者（producer）"}},[e._v("#")]),e._v(" 2.2 消息生产者（Producer）")]),e._v(" "),t("p",[e._v("负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。")]),e._v(" "),t("h3",{attrs:{id:"_2-3-消息消费者（consumer）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-消息消费者（consumer）"}},[e._v("#")]),e._v(" 2.3 消息消费者（Consumer）")]),e._v(" "),t("p",[e._v("负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。")]),e._v(" "),t("h3",{attrs:{id:"_2-4-主题（topic）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-主题（topic）"}},[e._v("#")]),e._v(" 2.4 主题（Topic）")]),e._v(" "),t("p",[e._v("表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。")]),e._v(" "),t("h3",{attrs:{id:"_2-5-代理服务器（broker-server）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-代理服务器（broker-server）"}},[e._v("#")]),e._v(" 2.5 代理服务器（Broker Server）")]),e._v(" "),t("p",[e._v("消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。")]),e._v(" "),t("h3",{attrs:{id:"_2-6-名字服务（name-server）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-名字服务（name-server）"}},[e._v("#")]),e._v(" 2.6 名字服务（Name Server）")]),e._v(" "),t("p",[e._v("名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。")]),e._v(" "),t("h3",{attrs:{id:"_2-7-拉取式消费（pull-consumer）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-拉取式消费（pull-consumer）"}},[e._v("#")]),e._v(" 2.7 拉取式消费（Pull Consumer）")]),e._v(" "),t("p",[e._v("Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。")]),e._v(" "),t("h3",{attrs:{id:"_2-8-推动式消费（push-consumer）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-推动式消费（push-consumer）"}},[e._v("#")]),e._v(" 2.8 推动式消费（Push Consumer）")]),e._v(" "),t("p",[e._v("Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。")]),e._v(" "),t("h3",{attrs:{id:"_2-9-生产者组（producer-group）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-9-生产者组（producer-group）"}},[e._v("#")]),e._v(" 2.9 生产者组（Producer Group）")]),e._v(" "),t("p",[e._v("同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。")]),e._v(" "),t("h3",{attrs:{id:"_2-10-消费者组（consumer-group）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-10-消费者组（consumer-group）"}},[e._v("#")]),e._v(" 2.10 消费者组（Consumer Group）")]),e._v(" "),t("p",[e._v("同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。")]),e._v(" "),t("h3",{attrs:{id:"_2-11-集群消费（clustering）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-11-集群消费（clustering）"}},[e._v("#")]),e._v(" 2.11 集群消费（Clustering）")]),e._v(" "),t("p",[e._v("集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。")]),e._v(" "),t("h3",{attrs:{id:"_2-12-广播消费（broadcasting）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-12-广播消费（broadcasting）"}},[e._v("#")]),e._v(" 2.12 广播消费（Broadcasting）")]),e._v(" "),t("p",[e._v("广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。")]),e._v(" "),t("h3",{attrs:{id:"_2-13-普通顺序消息（normal-ordered-message）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-13-普通顺序消息（normal-ordered-message）"}},[e._v("#")]),e._v(" 2.13 普通顺序消息（Normal Ordered Message）")]),e._v(" "),t("p",[e._v("普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。")]),e._v(" "),t("h3",{attrs:{id:"_2-14-严格顺序消息（strictly-ordered-message）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-14-严格顺序消息（strictly-ordered-message）"}},[e._v("#")]),e._v(" 2.14 严格顺序消息（Strictly Ordered Message）")]),e._v(" "),t("p",[e._v("严格顺序消息模式下，消费者收到的所有消息均是有顺序的。")]),e._v(" "),t("h3",{attrs:{id:"_2-15-消息（message）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-15-消息（message）"}},[e._v("#")]),e._v(" 2.15 消息（Message）")]),e._v(" "),t("p",[e._v("消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。")]),e._v(" "),t("h3",{attrs:{id:"_2-16-标签（tag）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-16-标签（tag）"}},[e._v("#")]),e._v(" 2.16 标签（Tag）")]),e._v(" "),t("p",[e._v("为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。")]),e._v(" "),t("h2",{attrs:{id:"_3-路由元信息相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-路由元信息相关"}},[e._v("#")]),e._v(" 3. 路由元信息相关")]),e._v(" "),t("blockquote",[t("p",[e._v("NameServer路由中心：")])]),e._v(" "),t("blockquote",[t("p",[e._v("topicQueueTable：Topic消息队列路由信息，消息发送时根据路由表进行负载均衡")])]),e._v(" "),t("blockquote",[t("p",[e._v("brokerAddrTable：Broker基础信息，包含brokerName、所属集群名称、主备Broker地址")])]),e._v(" "),t("blockquote",[t("p",[e._v("clusterAddrTable：Broker集群信息，存储集群中所有Broker 名称")])]),e._v(" "),t("blockquote",[t("p",[e._v("brokerLiveTable：Broker状态信息。NameServer 每次收到心跳包时会替换该信息")])]),e._v(" "),t("blockquote",[t("p",[e._v("filterServerTable：Broker.上的FilterServer列表，用于类模式消息过滤")])]),e._v(" "),t("blockquote",[t("p",[e._v("TopicRouteData：")])]),e._v(" "),t("h2",{attrs:{id:"_4-rocketmq消息发送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-rocketmq消息发送"}},[e._v("#")]),e._v(" 4. RocketMQ消息发送")]),e._v(" "),t("blockquote",[t("p",[e._v("RocketMQ发送普通消息有三种模式：可靠同步发送（sync）、可靠异步发送（async）、单向发送（Oneway）")])]),e._v(" "),t("p",[e._v("Message中的属性：")]),e._v(" "),t("blockquote",[t("p",[e._v("topic：消息主题")])]),e._v(" "),t("blockquote",[t("p",[e._v("tag：消息tag，用于消息过滤")])]),e._v(" "),t("blockquote",[t("p",[e._v("keys：Message索引键，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息")])]),e._v(" "),t("blockquote",[t("p",[e._v("waitStoreMsgOK：消息发送时是否等消息存储完成后再返回")])]),e._v(" "),t("blockquote",[t("p",[e._v("delayTimeLevel：消息延迟级别，用于定时消息或消息重试")])]),e._v(" "),t("blockquote",[t("p",[e._v("offset：偏移量？？？？")])]),e._v(" "),t("blockquote",[t("p",[e._v("MQClientInstance：MQClientInstance封装了RocketMQ网络处理API，是消息生产者（Producer）、消息消费者（Consumer）与NameServer、Broker打交道的网络通道")])]),e._v(" "),t("blockquote",[t("p",[e._v("消息发送流程主要步骤：验证消息、查找路由、消息发送（包含异常处理机制）")])]),e._v(" "),t("Boxx",{attrs:{type:"tip",content:"本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。"}})],1)}),[],!1,null,null,null);r.default=s.exports}}]);