(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{474:function(e,r,a){"use strict";a.r(r);var t=a(2),v=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("本篇文章主要分析并总结整个RocketMQ的“大脑“ NameServer。NameServer主要负责RocketMQ的订阅信息（路由信息，下文统一称为路由信息）、服务注册及服务发现。相信大家对”服务注册”及“服务发现”这两个词并不会陌生，近些年火爆的分布式以及微服务都会有服务注册中心，用于对服务提供者注册服务信息，然后对于服务调用者，则从注册中心订阅服务信息，并通过订阅获得的服务信息完成“网络通信”。")]),e._v(" "),a("p",[e._v("那么RocketMQ中的服务注册和服务发现指的是什么呢？RocketMQ中的路由信息是什么呢？")]),e._v(" "),a("p",[e._v("消息中间件的设计思路一般基于主题的订阅发布机制，消息生产者（Producer）发送某一主题的消息到消息服务器，消息服务器负责该消息的持久化存储，消息消费者（Consumer）订阅感兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费消费者（Push模式）或者消息消费者主动从消息服务器拉取消息（Pull模式），从而实现了消息生产者和消息消费者之间的解耦。在分布式系统中为了避免服务器的单点故障导致整个系统瘫痪，通常会部署多台机器来共同提供保证性服务，同样的RocketMQ中也会部署多台消息服务器拉力承担消息的存储，那么对于这么多台的机器生产者该往哪台机器发送消息？消费者又该订阅哪台机器并获取消息进行消费呢？")]),e._v(" "),a("p",[e._v("接下来的RocketMQ的NameServer原理分析会一一解答。")]),e._v(" "),a("h2",{attrs:{id:"_1-nameserver的架构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-nameserver的架构设计"}},[e._v("#")]),e._v(" 1. NameServer的架构设计")]),e._v(" "),a("p",[e._v("下面介绍下RocketMQ架构的拓扑图。")]),e._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"rocketmq_01",href:"https://coderbruis.github.io/javaDocs/img/rocketmq/rocketmq_01_01.png"}},[a("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/rocketmq/rocketmq_01_01.png",alt:"rocketmq_01"}})])]),e._v(" "),a("p",[e._v("上图中有四大组成部分，分别是：")]),e._v(" "),a("ol",[a("li",[e._v("NameServer   负责服务注册")]),e._v(" "),a("li",[e._v("Broker       负责接收、存储并转发消息？？")]),e._v(" "),a("li",[e._v("Producer     负责发送消息")]),e._v(" "),a("li",[e._v("Consumer     负责消费消息")])]),e._v(" "),a("p",[e._v("Broker消息服务器在启动时向所有NameServer注册，消息生产者(Producer)在发送消息之前先从NameServer获取Broker服务器地址列表，然后根据负载算法从列表中选择一台消息服务器进行消息发送。NameServer与每台Broker服务器保持长连接，并间隔30s检\n测Broker是否存活，如果检测到Broker宕机，则从路由注册表中将其移除。")]),e._v(" "),a("p",[e._v("在NameServer集群中，每个NameServer服务器彼此之间是互补通信的，也就是NameServer服务器之间在某一时刻数据并不会完全相同。")]),e._v(" "),a("h2",{attrs:{id:"_2-nameserver的启动流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-nameserver的启动流程"}},[e._v("#")]),e._v(" 2. NameServer的启动流程")]),e._v(" "),a("p",[e._v("TODO 文章细节持续完善...")]),e._v(" "),a("p",[e._v("NameServer重点启动类：")]),e._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[e._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("apache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("rocketmq"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("namesrv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("NamesrvStartup")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("启动步骤调用链路：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("NamesrvStartup#main")])]),e._v(" "),a("li",[a("p",[e._v("NamesrvStartup#main0")])]),e._v(" "),a("li",[a("p",[e._v("NamesrvStartup#createNamesrvController")])]),e._v(" "),a("li",[a("p",[e._v("NamesrvStartup#start")])]),e._v(" "),a("li",[a("p",[e._v("NamesrvController#initialize")])]),e._v(" "),a("li",[a("p",[e._v("NamesrvController#start")])]),e._v(" "),a("li",[a("p",[e._v("首先来解析配置文件，需要填充NameServerConfig、NettyServerConfig 属性值")])]),e._v(" "),a("li",[a("p",[e._v("根据启动属性创建NamesrvController实例，并初始化该实例，NameServerController实例为NameServer核心控制器")])]),e._v(" "),a("li",[a("p",[e._v("注册JVM钩子函数并启动服务器，以便监听Broker、消息生产者的网络请求")])])]),e._v(" "),a("h2",{attrs:{id:"_3-nameserver路由注册、故障剔除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-nameserver路由注册、故障剔除"}},[e._v("#")]),e._v(" 3. NameServer路由注册、故障剔除")]),e._v(" "),a("p",[e._v("TODO 文章细节持续完善...")])])}),[],!1,null,null,null);r.default=v.exports}}]);