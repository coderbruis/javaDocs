(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{453:function(s,i,t){"use strict";t.r(i);var r=t(2),e=Object(r.a)({},(function(){var s=this,i=s.$createElement,t=s._self._c||i;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"_1-特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-特点"}},[s._v("#")]),s._v(" 1. 特点")]),s._v(" "),t("ul",[t("li",[s._v("内存数据库，速度快，也支持数据的持久化")]),s._v(" "),t("li",[s._v("Redis不仅仅支持简单的key-value类型的数据，同时还提供Lists、Hashes、Sets、Sorted Sets等多种数据结构的存储。")]),s._v(" "),t("li",[s._v("Redis支持数据的备份（master-value）与集群（分片存储），以及拥有哨兵监控机制")]),s._v(" "),t("li",[s._v("支持事务")])]),s._v(" "),t("h2",{attrs:{id:"_2-优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-优势"}},[s._v("#")]),s._v(" 2. 优势")]),s._v(" "),t("ul",[t("li",[s._v("性能极高：单机节点的Redis能对256字节的数据的读的速度是110000次/s，写的速度是81000次/s。")]),s._v(" "),t("li",[s._v("丰富的数据类型：Redis支持Strings、Lists、Hashes、Sets、Sorted Sets等多种数据结构的存储。")]),s._v(" "),t("li",[s._v("原子操作：Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行（事务）。")]),s._v(" "),t("li",[s._v("丰富的特性：Redis还支持publish / subscribe，通知，key过期等特性。")])]),s._v(" "),t("h2",{attrs:{id:"_3-redis架构演变过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis架构演变过程"}},[s._v("#")]),s._v(" 3. Redis架构演变过程")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("单节点")]),s._v(" "),t("p",[s._v("就是一台Redis服务节点，读写请求都达到这台节点上，并发量大的时候，这单台的Redis节点会有非常大的压力。")])]),s._v(" "),t("li",[t("p",[s._v("多节点")]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis01",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-01.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-01.jpg",alt:"redis01"}})])]),s._v(" "),t("p",[s._v("对于多节点，读、写请求都落在一个节点上，压力大，且容易打挂这台节点机。")])]),s._v(" "),t("li",[t("p",[s._v("主从节点")]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis02",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-02.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-02.jpg",alt:"redis02"}})])]),s._v(" "),t("p",[s._v("进行主从分离，一个主节点配上两个从节点，主节点负责写请求，两个从节点负责读请求，读写分离，减少节点的压力。")])]),s._v(" "),t("li",[t("p",[s._v("哨兵机制")]),s._v(" "),t("p",[s._v("但是对于主从分离的架构，如果主节点挂了，那么就没法进行写请求了。那么此时就需要引入哨兵机制来进行主节点的选举，但如果只有一个哨兵来进行选举并决定了哪台从节点变成主节点，就有点太过于草率了，所以需要设立奇数个的\n哨兵来进行选举，当选举结果大于 1/2时，就执行结果。")]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis03",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-03.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-03.jpg",alt:"redis03"}})])]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis04",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-04.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-04.jpg",alt:"redis04"}})])]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis05",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-05.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-05.jpg",alt:"redis05"}})])])]),s._v(" "),t("li",[t("p",[s._v("集群模式")]),s._v(" "),t("p",[s._v("对于主从架构，每个从节点都会多复制一份数据，当数据量变大时，这样从节点也吃不消，所以此时需要升级为集群模式，对数据进行分片，数据共享。")]),s._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"redis06",href:"https://coderbruis.github.io/javaDocs/img/redis/redis01-06.jpg"}},[t("img",{attrs:{src:"https://coderbruis.github.io/javaDocs/img/redis/redis01-06.jpg",alt:"redis06"}})])])])])])}),[],!1,null,null,null);i.default=e.exports}}]);